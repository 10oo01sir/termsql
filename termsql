#!/bin/python
#
#The MIT License (MIT)
#
#Copyright (c) 2014 Tobias Glaesser
#
#Permission is hereby granted, free of charge, to any person obtaining a copy
#of this software and associated documentation files (the "Software"), to deal
#in the Software without restriction, including without limitation the rights
#to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#copies of the Software, and to permit persons to whom the Software is
#furnished to do so, subject to the following conditions:
#
#The above copyright notice and this permission notice shall be included in all
#copies or substantial portions of the Software.
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#SOFTWARE.

#NOTICE: please contribute improvements back to the project, it's very much appreciated

#TODO:
#-escape strings before for insertion into database
#-fix --head feature
#-

import fileinput
import subprocess
import sys
import argparse
import tempfile
import os
import sqlite3

VERSION = "0.1"
#configureable default values
sqlite_cmd = 'sqlite3'
table_name = 'tbl'
sql_db_file = '/tmp/termsql.db'
delimiter = ' '
separator = '' #default to whatever sqlite defaults to
mode = 'list'

#setup command line parser
parser = argparse.ArgumentParser(description='Convert text into SQL table and query it', formatter_class=argparse.RawDescriptionHelpFormatter, epilog='''examples:
  ps aux | termsql "select * from tbl where COL0='root' limit 5"
    (outputs 5 processes that are running as root)
  df -h | termsql -1 "select Filesystem from tbl order by '1K-blocks' limit 1"
    (return the largest device)
  cat /proc/cpuinfo | termsql "select COL2 from tbl where COL0='bogomips'"
    (how many bogomips does your system have?)
  termsql --infile /etc/group -d ':' "select COL0 from tbl"
    (read from file, use : as delimiter, shows all groups in /etc/group)''')
parser.add_argument("query", nargs='?', default='', help="SQL Query string")
parser.add_argument("-1", "--head", help="use first line/head(er) for column names", action="store_true")
parser.add_argument("-d", "--delimiter",  nargs='?', help="custom delimiter (default is space)") 
parser.add_argument("-p","--separator", nargs='?', help="set sqlite output field separator (default is |)")
parser.add_argument("-w","--whitespace", help="use whitespace as field separator (default is |)",action="store_true")
parser.add_argument("-m","--mode", nargs='?', help="set sqlite output mode i.e.: csv, column, html, insert, line, list, tabs, tcl (default is list)")
parser.add_argument("-i","--infile",  nargs='?', help="use file as input instead of stdin")
parser.add_argument("-o","--outfile", nargs='?', help="location/filename to use for sql database (by default a tempfile is used)")
parser.add_argument("-t","--table", nargs='?', help="tablename (must be a valid sqlite tablename)")
parser.add_argument("-s","--sqlite", nargs='?', help="path to sqlite executable")
parser.add_argument("-v","--version", help="display version information", action="store_true")
args = parser.parse_args()


#process command line input
if args.mode:
    mode = args.mode
if args.delimiter:
    delimiter = args.delimiter
if args.separator:
    separator = args.separator
if args.whitespace:
    separator = ' '
if args.outfile:
    sql_db_file = args.outfile
if args.table:
    table_name = args.table
if args.infile:
    infile = open(args.infile)
else:
    infile = sys.stdin
if args.sqlite:
    sqlite_cmd = args.sqlite
if args.version:
    print VERSION
    exit(0)
   

#simplify subprocess.call
def shell(str):
    subprocess.call(str, shell=True)

colnames = [] #only needed when using --head optional arg

#get name of column x
def get_col_name(i):
    if args.head and len(colnames) > i:
        return colnames[i]
    else:
        return "COL"+str(i)

inserts = []

def isfloat(value):
  try:
    float(value)
    return True
  except ValueError:
    return False

colprobs = {}
def update_colprobs(col,data):
    if not col in colprobs:
        colprobs[col] = {}
        colprobs[col]["INTEGER"] = True
        colprobs[col]["REAL"] = True
        colprobs[col]["TEXT"] = True
    if not data.isdigit():
        colprobs[col]["INTEGER"] = False        
    if not isfloat(data):
        colprobs[col]["REAL"] = False

def get_col_type(col):
    if not col in colprobs:
        return "TEXT"
    elif colprobs[col]["INTEGER"]:
        return "INTEGER"
    elif colprobs[col]["REAL"]:
        return "REAL"
    return "TEXT"


#build sql string to insert row
def build_insert(row):
    insert = []
    c = 0
    for col in row:
        insert.append(col)
        update_colprobs(c,col)
        c += 1
    inserts.append(insert)

#get column names using row
def get_col_names(row):
    count = 0
    for col in row:
        colnames.append(col)
        count += 1

#traverse input
max_count = 0    
first_line = True
for line in infile.readlines():
    if delimiter != ' ':
        row = line.rstrip('\r\n').split(delimiter)
    else:
        row = line.split()        
    if len(row) > max_count:
       max_count = len(row)
    if first_line and args.head:
        get_col_names(row)
    else:
        build_insert(row)
    first_line = False

temp = []
for ins in inserts:
    ins.extend([None] * (max_count - len(ins)))
    temp.append(ins)
inserts = temp

#create create database string
if max_count > 0:
    create_table_string =  "create table \""+table_name+"\"("
    for x in range(0,max_count):
        if x > 0:
            create_table_string += ", "
        create_table_string += '"'+ get_col_name(x) + '"' + " " + get_col_type(x)
    create_table_string += ");"
else:
    exit(0)


#remove database file, if exist
#if os.path.isfile(sql_db_file):
#    os.remove(sql_db_file)

conn = sqlite3.connect(sql_db_file)
conn.text_factory = str
c = conn.cursor()

c.execute("drop table if exists \""+table_name+"\";")
#create database and databasefile
c.execute(create_table_string)

temp = []
temp.extend('?' * (max_count))
placeholder_str = ",".join(temp)

#execute inserts, fill table with row data
#shell('cat '+f.name+ ' | '+sqlite_cmd + ' ' + sql_db_file)
c.executemany('insert into tbl values ('+placeholder_str+')', inserts)
conn.commit()
                     

if args.query == "":
   args.query = "select * from \""+table_name+"\""

command_string = sqlite_cmd + ' -' + mode + ' '
if separator != '':
    command_string += ' -separator \"' + separator + '\" '

#for row in c.execute(args.query):
#    print '|'.join((item or '') for item in row )
shell(command_string + sql_db_file + ' \"' + args.query +"\"")

#print colprobs
