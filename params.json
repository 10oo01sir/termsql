{"name":"Termsql","tagline":"Convert text from a file or from stdin into SQL table and query it instantly. Uses sqlite as backend. The idea is to make SQL into a tool on the command line or in scripts.","body":"<body>\r\n<div class=\"mandoc\">\r\n<table summary=\"Document Header\" class=\"head\" width=\"100%\">\r\n<col width=\"30%\">\r\n<col width=\"30%\">\r\n<col width=\"30%\">\r\n<tbody>\r\n<tr>\r\n<td class=\"head-ltitle\">\r\nTERMSQL(1)</td>\r\n<td class=\"head-vol\" align=\"center\">\r\nGeneral Commands Manual</td>\r\n<td class=\"head-rtitle\" align=\"right\">\r\nTERMSQL(1)</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<div class=\"section\">\r\n<h1 id=\"x4e414d45\">NAME</h1> <b class=\"name\">termsql</b> &#8212; <span class=\"desc\">Convert text into SQL table and query it</span></div>\r\n<div class=\"section\">\r\n<h1 id=\"x53594e4f50534953\">SYNOPSIS</h1><table class=\"synopsis\">\r\n<col style=\"width: 7.00ex;\">\r\n<col>\r\n<tbody>\r\n<tr>\r\n<td>\r\ntermsql</td>\r\n<td>\r\n[-h] [-1] [-0] [-d DELIMITER] [-p SEPARATOR] [-l LINE_AS_COLUMN] [-k KEY_COLUMNS] [-c COLUMNS] [--calc CALC] [-w] [-H OFFSET_HEAD] [-T OFFSET_TAIL] [-M MAX_ROWS] [-C] [-D] [-m MODE] [-r MERGE] [-x] [-a] [-i INFILE] [-o OUTFILE] [-f FILE] [-e] [-q QUERYFILE] [-t TABLE] [-s SQLITE] [-v] [query]</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n<div class=\"section\">\r\n<h1 id=\"x4445534352495054494f4e\">DESCRIPTION</h1> Convert text into SQL table and query it</div>\r\n<div class=\"section\">\r\n<h1 id=\"x4f5054494f4e53\">OPTIONS</h1><dl style=\"margin-top: 0.00em;margin-bottom: 0.00em;\" class=\"list list-tag\">\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;h</b>, <b class=\"flag\">&#45;-help</b></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\nshow this help message and exit</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;1</b>, <b class=\"flag\">&#45;-head</b></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\nuse first line/head(er) for column names</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;0</b>, <b class=\"flag\">&#45;-show-header</b></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\nshow column names as header in output (not shown by default)</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;d</b> <i class=\"arg\">[DELIMITER]</i>, <b class=\"flag\">&#45;-delimiter</b> <i class=\"arg\">[DELIMITER]</i></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\ncustom delimiter (default is whitespace)</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;p</b> <i class=\"arg\">[SEPARATOR]</i>, <b class=\"flag\">&#45;-separator</b> <i class=\"arg\">[SEPARATOR]</i></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\nset sqlite output field separator (default depends on output mode. ie. for list '|' is the default and for csv ',' is the default)</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;l</b> <i class=\"arg\">[LINE_AS_COLUMN]</i>, <b class=\"flag\">&#45;-line-as-column</b> <i class=\"arg\">[LINE_AS_COLUMN]</i></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\neach line of input is a whole column, next row begins after n lines</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;k</b> <i class=\"arg\">[KEY_COLUMNS]</i>, <b class=\"flag\">&#45;-key-columns</b> <i class=\"arg\">[KEY_COLUMNS]</i></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\none or more columns can make up the primary key (i.e -k COL0 or -c one,two,three -k one,two)</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;c</b> <i class=\"arg\">[COLUMNS]</i>, <b class=\"flag\">&#45;-columns</b> <i class=\"arg\">[COLUMNS]</i></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\nset custom column names (ie. -c 'name,street,age')</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;-calc</b> <i class=\"arg\">[CALC]</i></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\nuse sqlite as simple calculator, you can do multiple calculations separated by commata (i.e. &quot;(5*109.05)/2 , 345+789&quot;) In this mode stdin input is ignored</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;w</b>, <b class=\"flag\">&#45;-whitespace</b></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\nuse whitespace as field separator (default is |). equal to mode column</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;H</b> <i class=\"arg\">[OFFSET_HEAD]</i>, <b class=\"flag\">&#45;-offset-head</b> <i class=\"arg\">[OFFSET_HEAD]</i></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\nignore first n lines of input</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;T</b> <i class=\"arg\">[OFFSET_TAIL]</i>, <b class=\"flag\">&#45;-offset-tail</b> <i class=\"arg\">[OFFSET_TAIL]</i></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\nignore last n lines of input</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;M</b> <i class=\"arg\">[MAX_ROWS]</i>, <b class=\"flag\">&#45;-max-rows</b> <i class=\"arg\">[MAX_ROWS]</i></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\ndon't insert more than n rows into database</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;C</b>, <b class=\"flag\">&#45;-dump-create-table</b></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\ndump create table SQL</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;D</b>, <b class=\"flag\">&#45;-dump</b></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\ndump complete SQL to create table and content</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;m</b> <i class=\"arg\">[MODE]</i>, <b class=\"flag\">&#45;-mode</b> <i class=\"arg\">[MODE]</i></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\nset sqlite output mode i.e.: csv, column, html, insert, line, list, tabs, tcl (default is list)</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;r</b> <i class=\"arg\">[MERGE]</i>, <b class=\"flag\">&#45;-merge</b> <i class=\"arg\">[MERGE]</i></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\nmerges all columns from column n to the last one into one. This is useful when you have data like filenames with whitespaces in it, to prevent it from getting split by the delimiter. Note that counting starts from 0, therefore n=0 is the first column ...</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;x</b>, <b class=\"flag\">&#45;-select-all</b></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\nadd final SELECT * FROM to user defined query</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;a</b>, <b class=\"flag\">&#45;-append</b></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\ndon't DROP TABLE instead just append data to existing table. If the existing table doesn't have enough columns it will be ALTERed accordingly, if possible</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;i</b> <i class=\"arg\">[INFILE]</i>, <b class=\"flag\">&#45;-infile</b> <i class=\"arg\">[INFILE]</i></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\nuse file as input instead of stdin</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;o</b> <i class=\"arg\">[OUTFILE]</i>, <b class=\"flag\">&#45;-outfile</b> <i class=\"arg\">[OUTFILE]</i></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\nlocation/filename to use for sql database (by default a tempfile is used)</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;f</b> <i class=\"arg\">[FILE]</i>, <b class=\"flag\">&#45;-file</b> <i class=\"arg\">[FILE]</i></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\nwrite output to file instead of stdout. It's overwriting the whole file, and not just appending, so please be cautious</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;e</b>, <b class=\"flag\">&#45;-edit</b></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\nwrites to the input file instead of stdout. For this to work the input file has to be specified with the -i/--infile option. It's overwriting the whole file, and not just appending, so please be cautious</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;q</b> <i class=\"arg\">[QUERYFILE]</i>, <b class=\"flag\">&#45;-queryfile</b> <i class=\"arg\">[QUERYFILE]</i></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\nload complex query from file, queries on the commandline get executed last</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;t</b> <i class=\"arg\">[TABLE]</i>, <b class=\"flag\">&#45;-table</b> <i class=\"arg\">[TABLE]</i></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\ntablename (must be a valid sqlite tablename)</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;s</b> <i class=\"arg\">[SQLITE]</i>, <b class=\"flag\">&#45;-sqlite</b> <i class=\"arg\">[SQLITE]</i></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\npath to sqlite executable</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n<b class=\"flag\">&#45;v</b>, <b class=\"flag\">&#45;-version</b></dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\ndisplay version information</dd>\r\n</dl>\r\n</div>\r\n<div class=\"section\">\r\n<h1 id=\"x5553414745\">USAGE</h1> By default termsql reads from stdin and converts each incoming line into a row it stores inside a sqlite database in a temporary file.<p>\r\nIt separates columns by whitespace, because on the command line most programs usually present information in the output in that way. You can supply option -d to change that behavior and split columns by any character or string of characters of your choosing. Option -l/--line-as-columns on the other hand splits columns by newlines, and expects a number by the user to know how many columns the table has.<p>\r\nThe most powerful part of termsql is that it allows users to query these newly created databases with the full power of sqlite. When no user query is supplied as last argument it defaults to &quot;select * from tbl&quot;, as you can see from this the default name of the table is tbl. You can change that table name with the -t option.<p>\r\nAll sqlite SQL syntax like select/update/delete/group by/where/order by/limit and all sqlite functions such as date('now'), SUM(*) or ABS(X) can be used to modify the table and the output of termsql.<p>\r\nThe default output mode is the default output mode of sqlite, which is called list and separates columns by |. A nice output mode in a terminal is column, which you can activate with -m column or its synonymous option -w. -m csv and -m html output in the according formats. -m line lists one line per column in a key/value pair kind of fashion. Option -0/--show-header activates the header with column names in the output.<p>\r\nOften the first line of input contains the column names and option -1/--head ensures that these names are used as the actual column names in the table. If you want to specify your own custom column names, you can use the -c/--columns option followed by a comma separated list of column names. By default columns are named by their position starting with COL0. User defined column names take precedence over column names automatically found using -1/--head. If you're using the -1 option and -c at the same time and the header only contains 3 names, while you define 2 names with the -c option and the total number of columns in the table is 5 the actual column names of the table would look something like this: &quot;coption1&quot;,&quot;coption2&quot;,&quot;headername3&quot;,&quot;COL3&quot;,&quot;COL4&quot;.<p>\r\nIf you end up having column names with special characters in them it's good to know the sqlite syntax to escape column names like this &quot;select [%CPU],[1k-blocks] from tbl&quot;. As you see wrapping column names in brackets can save the day.<p>\r\nYou may want to convert input into a permanent database, for that you simply use the -o option followed by the filename of the database.<p>\r\nInstead of reading from stdin termsql can read from a file supplied with the -i option. If you make modifications to such input you may want to save it in the same file again. Option -e only works in conjunction with the -i option and automatically overwrites the input file with the new output. Make sure to check that the output is actually satisfying before you use this method. With the -f option you can supply a different file to write the output to.<p>\r\nFor looking at the internals of the SQL the options -m insert, -D and -C may be interesting. Mode insert outputs the result of select as a series of SQL insert statements. -D dumps the complete table and data SQL, while -C only dumps the SQL the table was created with.<p>\r\nWhen creating the database termsql detects for each column automatically the best datatype, so numbers will get stored as integer or float if possible.<p>\r\nOption --calc X is a special mode that emulates &quot;select X from tbl&quot; and doesn't create a table or read input at all. You can do calculations like this termsql --calc &quot;2+10,100/25&quot; or you can use sqlite functions like this termsql --calc date('now').<div style=\"height: 1.00em;\">\r\n&#160;</div>\r\n</div>\r\n<div class=\"section\">\r\n<h1 id=\"x4558414d504c4553\">EXAMPLES</h1><dl style=\"margin-top: 0.00em;margin-bottom: 0.00em;\" class=\"list list-tag\">\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n-$ ps aux | termsql &#34;select * from tbl where COL0='root' limit 5&#34;</dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\n<div style=\"height: 1.00em;\">\r\n&#160;</div>\r\noutputs 5 processes that are running as root</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n-$ df | termsql -1 'select Filesystem from tbl order by [1K-blocks] desc limit 1'</dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\n<div style=\"height: 1.00em;\">\r\n&#160;</div>\r\nreturns the largest device</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n-$ cat /proc/cpuinfo | termsql &#34;select COL2 from tbl where COL0='bogomips'&#34;</dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\n<div style=\"height: 1.00em;\">\r\n&#160;</div>\r\nhow many bogomips does your system have?</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n-$ termsql --infile /etc/group -d ':' &#34;select COL0 from tbl&#34;</dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\n<div style=\"height: 1.00em;\">\r\n&#160;</div>\r\nread from file, use : as delimiter, shows all groups in /etc/group</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n-$ termsql -i MyCSVFile.CSV -t fancytable -d ',' -1 -o mysqlite.db</dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\n<div style=\"height: 1.00em;\">\r\n&#160;</div>\r\ncreates a new sqlite database from a CSV file. -d ',' tells termsql to use commata as delimiter. -1 tells termsql that the first line of the CSV file is not data and instead the column names and termsql creates database columns with those names accordingly. -t fancytable sets the tablename to fancytable</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n-$ sensors | termsql &#34;select COL2 from tbl where COL0='Core'&#34;</dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\n<div style=\"height: 1.00em;\">\r\n&#160;</div>\r\nextract the temperature from all your CPU cores</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n-$ export LC_ALL=en_US; top -b | head | termsql -1 -H 6 &#34;select [PID],[USER],[COMMAND],[%CPU] from tbl where [%CPU]&gt;=25&#34;</dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\n<div style=\"height: 1.00em;\">\r\n&#160;</div>\r\ntermsql doesn't recognize numbers like &quot;25,3&quot; as numbers, but as strings. export LC_ALL=en_US ensures that top outputs numbers that are easy for termsql/sqlite to digest (ie. &quot;25.3&quot;). -H 6 makes termsql disregard the first 6 lines. We select only the processes with more than 25% cpu usage and output their PID,USER,COMMAND and %CPU.</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n-$ export DISPLAY=$(ps aux | termsql &#34;select COL11 from tbl where COL10 like '%Xorg.bin%' limit 1&#34;)</dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\n<div style=\"height: 1.00em;\">\r\n&#160;</div>\r\nset DISPLAY environment variable to what display X is running on right now, assuming that the X binary is called &quot;Xorg.bin&quot;)</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n-$ ls -lha /usr/bin/* | termsql -w -r 8 &#34;select * from tbl order by COL8 desc&#34;</dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\n<div style=\"height: 1.00em;\">\r\n&#160;</div>\r\n-r 8 merges the filenames into the 8th column. Then &quot;order by COL8 desc&quot; sorts them in reverse order. Due to -w the output looks nice on the command line</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n-$ termsql -m line --calc 2+2,23423./123</dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\n<div style=\"height: 1.00em;\">\r\n&#160;</div>\r\nTo use termsql as simple a calculator with the power of sqlite behind it, use the --calc option and a commata separated list of calculations you want to do. Sometimes you may need to append a dot . to a number to make sqlite aware that it's supposed to do floating point calculation. If you want to use paranthesis you may also need to use quotes like this --calc &quot;(2+2,23423./123)&quot;. The -m line option beautifies the output.</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n-$ cat /etc/fstab | termsql &#34;select COUNT(*) from tbl where COL2='ext4'&#34;</dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\n<div style=\"height: 1.00em;\">\r\n&#160;</div>\r\nhow many devices do you have in your fstab that are using the ext4 filesystem? COUNT(*) simply outputs the total number of rows that the current select/where statement would select.</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n-$ ps aux | termsql -m line -1 &#34;select USER,COUNT(*) from tbl group by USER&#34;</dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\n<div style=\"height: 1.00em;\">\r\n&#160;</div>\r\ncounts the total number of processes that each user has running. -1 gets the column names from the first line, therefore we can use USER instead of COL0 in the SQL statement. &quot;group by USER&quot; groups the rows of with identical USER together and for that reason COUNT(*) returns the total number of rows (in this case processes) for each USER. -m line beautifies the output.</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n-$ termsql -ei .config/Bitcoin/Bitcoin-Qt.conf -c key,value -d = -p = -x &#34;update tbl set value='true' where key='fMinimizeToTray'&#34;</dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\n<div style=\"height: 1.00em;\">\r\n&#160;</div>\r\nDemonstrates how you can use termsql to edit simple config files with key/value pairs. -i loads the config file as input and -e makes sure this same file is written to instead of stdout. Simply speaking: enabling edit mode. -d = sets the delimiter for splitting the input to = and -p = sets the separator for the output to = again, so that the output format matches the input format. -x appends a &quot;;select * from tbl&quot; to the user defined query, so that we get everything back that we put in. The user query is an SQL update statement which sets the value part of the key value pair to true, where the key is fMinimizeToTray. -c key,value allows us to use these convenient names instead of COL0 (key) and COL1 (value). Note that this approach may not always be perfect, for example in .config/Bitcoin/Bitcoin-Qt.conf there's a section line &quot;[General]&quot; which gets changed to &quot;[General]=&quot; after termsql is done with editing. Which may or may not be a problem depending on the program that uses the config file. It could easily be fixed with a tool like sed though.</dd>\r\n<dt class=\"list-tag\" style=\"margin-top: 1.00em;\">\r\n-$ termsql -ei my.config -c key,value -d = -p = -x &#34;delete from tbl where key IN ('entry1','entry2','entry3','entry4')&#34;</dt>\r\n<dd class=\"list-tag\" style=\"margin-left: 6.00ex;\">\r\n<div style=\"height: 1.00em;\">\r\n&#160;</div>\r\nAnalogous to the previous example this one would find and delete the key/value pair entries with the keys entry1, entry2, entry3 and entry4. Using IN in a where clause you can specifiy a list to match against instead of just a single value. Everything else from the previous example also applies in this one.</dd>\r\n</dl>\r\n</div>\r\n<table summary=\"Document Footer\" class=\"foot\" width=\"100%\">\r\n<col width=\"50%\">\r\n<col width=\"50%\">\r\n<tbody>\r\n<tr>\r\n<td class=\"foot-date\">\r\nNovember 30, 2014</td>\r\n<td class=\"foot-os\" align=\"right\">\r\nLinux 3.18.0-rc5+</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}